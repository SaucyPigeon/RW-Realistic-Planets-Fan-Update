//using HarmonyLib;
//using RimWorld;
//using RimWorld.Planet;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using Verse;
//using System.Reflection;
//using System.Reflection.Emit;

//namespace Planets_Code.Factions
//{
//	/*
//	Original code:
//	public static int RandomSettlementTileFor(Faction faction, bool mustBeAutoChoosable = false, Predicate<int> extraValidator = null)
//	{
//		for (int i = 0; i < 500; i++)
//		{
//			int num;
//			if ((from _ in Enumerable.Range(0, 100)
//			select Rand.Range(0, Find.WorldGrid.TilesCount)).TryRandomElementByWeight(delegate(int x)
//			{
//				Tile tile = Find.WorldGrid[x];
//				if (!tile.biome.canBuildBase || !tile.biome.implemented || tile.hilliness == Hilliness.Impassable)
//				{
//					return 0f;
//				}
//				if (mustBeAutoChoosable && !tile.biome.canAutoChoose)
//				{
//					return 0f;
//				}
//				if (extraValidator != null && !extraValidator(x))
//				{
//					return 0f;
//				}
//				if (ExcludedByTemperature(tile))
//				{
//					return 0f;
//				}
//				return tile.biome.settlementSelectionWeight;
//			}, out num))
//			{
//				if (TileFinder.IsValidTileForNewSettlement(num, null))
//				{
//					return num;
//				}
//			}
//		}
//		Log.Error("Failed to find faction base tile for " + faction, false);
//		return 0;
//	}

//	RPFU prefix:
//}

//	Boats transpiler:
//	if(instruction.opcode == OpCodes.Ldnull && instructionList[i-1].opcode == OpCodes.Ldloc_1)
//    {
//        ///Call method, grab new location and store
//        yield return new CodeInstruction(opcode: OpCodes.Ldarg_0);
//        yield return new CodeInstruction(opcode: OpCodes.Call, operand: AccessTools.Method(typeof(HelperMethods), nameof(HelperMethods.PushSettlementToCoast)));
//        yield return new CodeInstruction(opcode: OpCodes.Stloc_1);
//        yield return new CodeInstruction(opcode: OpCodes.Ldloc_1);
//    }
//    yield return instruction;


//	*/

//	public static class TileFinder_RandomSettlementTileFor
//	{
//		static TileFinderState state;

//		static class AutoGenerated
//		{
//			static bool ExcludedByTemperat ure(Tile tile)
//			{
//				return state.ExcludedByTemperature(tile);
//			}

//			[HarmonyTargetMethod]
//			static MethodBase TargetMethod()
//			{
//				var type = typeof(TileFinder).GetNestedType("<>c__DisplayClass1_0", AccessTools.all);
//				var method = type.GetMethods(AccessTools.all).Where(x => !x.IsConstructor).First();

//				return method;
//			}

//			[HarmonyTranspiler]
//			static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions, ILGenerator ilGenerator)
//			{
//				// After second-to-last return, add condition block

//				// load arg tile
//				// call bool ExcludedByTemperature(Tile)
//				// brfalse: goto END

//				// load 0 float
//				// return

//				// END

//				var targetInstruction = instructions
//					.Where(x => x.opcode == OpCodes.Ret)
//					.Reverse()
//					.Skip(1);

//				var mi_ExcludedByTemperature = AccessTools.Method(typeof(AutoGenerated), nameof(ExcludedByTemperature));

//				foreach (var instruction in instructions)
//				{
//					if (instruction.Equals(targetInstruction))
//					{
//						var jumpToEnd = ilGenerator.DefineLabel();
//						yield return new CodeInstruction(OpCodes.Ldloc_0) { labels = instruction.labels.ListFullCopy() };
//						instruction.labels.Clear();
//						yield return new CodeInstruction(OpCodes.Call, mi_ExcludedByTemperature);
//						yield return new CodeInstruction(OpCodes.Brfalse_S, jumpToEnd);

//						yield return new CodeInstruction(OpCodes.Ldc_R4);
//						yield return new CodeInstruction(OpCodes.Ret);

//						yield return new CodeInstruction(OpCodes.Nop) { labels = new List<Label>() { jumpToEnd } };
//					}
//					yield return instruction;
//				}
//			}
//		}

//		[HarmonyPatch(typeof(TileFinder))]
//		[HarmonyPatch(nameof(TileFinder.RandomSettlementTileFor))]
//		static class Written
//		{

//			static IEnumerable<CodeInstruction> Transpiler_0(IEnumerable<CodeInstruction> instructions)
//			{
//			}

//			static IEnumerable<CodeInstruction> Transpiler_1(IEnumerable<CodeInstruction> instructions)
//			{
//				return instructions;
//			}

//		}
//	}

//		//[HarmonyPatch(nameof(TileFinder.RandomSettlementTileFor))]
//		//[HarmonyTranspiler]
//		//public static IEnumerable<CodeInstruction> RandomSettlementTileFor_Transpiler(IEnumerable<CodeInstruction> instructions)
//		//{

//		//}

//		//[HarmonyPatch(nameof(TileFinder.RandomSettlementTileFor))]
//		//[HarmonyPrefix]
//		//[HarmonyPriority(Priority.High)]
//		//public static bool Prefix(Faction faction, ref int __result, bool mustBeAutoChoosable = false, Predicate<int> extraValidator = null)
//		//{
//		//	int num;
//		//	for (int i = 0; i < 2500; i++)
//		//	{
//		//		if ((
//		//		from _ in Enumerable.Range(0, 100)
//		//		select Rand.Range(0, Find.WorldGrid.TilesCount)).TryRandomElementByWeight<int>((int x) => {
//		//			Tile item = Find.WorldGrid[x];
//		//			if (!item.biome.canBuildBase || !item.biome.implemented || item.hilliness == Hilliness.Impassable)
//		//			{
//		//				return 0f;
//		//			}
//		//			if (mustBeAutoChoosable && !item.biome.canAutoChoose)
//		//			{
//		//				return 0f;
//		//			}
//		//			if (extraValidator != null && !extraValidator(x))
//		//			{
//		//				return 0f;
//		//			}
#region Transpiler
//		//			#region Transpiler patch
//		//			if (Controller.Settings.checkTemp.Equals(true))
//		//			{
//		//				if (i < 1000)
//		//				{
//		//					if (item.temperature < (minTemp - 45) || item.temperature > (maxTemp + 45))
//		//					{
//		//						return 0f;
//		//					}
//		//					if (item.temperature < (minTemp - 36) || item.temperature > (maxTemp + 36))
//		//					{
//		//						if (Rand.Value > 0.1f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 28) || item.temperature > (maxTemp + 28))
//		//					{
//		//						if (Rand.Value > 0.2f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 21) || item.temperature > (maxTemp + 21))
//		//					{
//		//						if (Rand.Value > 0.3f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 15) || item.temperature > (maxTemp + 15))
//		//					{
//		//						if (Rand.Value > 0.4f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 10) || item.temperature > (maxTemp + 10))
//		//					{
//		//						if (Rand.Value > 0.5f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 6) || item.temperature > (maxTemp + 6))
//		//					{
//		//						if (Rand.Value > 0.6f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 3) || item.temperature > (maxTemp + 3))
//		//					{
//		//						if (Rand.Value > 0.7f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 1) || item.temperature > (maxTemp + 1))
//		//					{
//		//						if (Rand.Value > 0.8f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < minTemp || item.temperature > maxTemp)
//		//					{
//		//						if (Rand.Value > 0.9f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//				}
//		//				else if (i < 1500)
//		//				{
//		//					if (item.temperature < (minTemp - 45) || item.temperature > (maxTemp + 45))
//		//					{
//		//						if (Rand.Value > 0.2f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 36) || item.temperature > (maxTemp + 36))
//		//					{
//		//						if (Rand.Value > 0.4f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 28) || item.temperature > (maxTemp + 28))
//		//					{
//		//						if (Rand.Value > 0.6f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//					if (item.temperature < (minTemp - 21) || item.temperature > (maxTemp + 21))
//		//					{
//		//						if (Rand.Value > 0.8f)
//		//						{
//		//							return 0f;
//		//						}
//		//					}
//		//				}
//		//			}
//		//			#endregion
#endregion
//		//			return item.biome.settlementSelectionWeight;
//		//		}, out num))
//		//		{
//		//			if (TileFinder.IsValidTileForNewSettlement(num, null))
//		//			{
//						if (UseFactionSprawl(num, Faction)
//						{
//							return num;
//						}
#region Transpiler
//		//			}
#endregion
//		//		}
//		//	}
//		//	Log.Warning(string.Concat("Failed to find faction base tile for ", faction));
//		//	if (Controller.failureCount.ContainsKey(faction))
//		//	{
//		//		Controller.failureCount[faction]++;
//		//		if (Controller.failureCount[faction] == 10)
//		//		{
//		//			Controller.failureCount.Remove(faction);
//		//			if (Controller.factionCenters.ContainsKey(faction))
//		//			{
//		//				Controller.factionCenters.Remove(faction);
//		//				Log.Warning("  Relocating faction center.");
//		//			}
//		//		}
//		//	}
//		//	else
//		//	{
//		//		Log.Warning("  Retrying.");
//		//		Controller.failureCount.Add(faction, 1);
//		//	}
//		//	__result = 0;
//		//	return false;
//		//}
//}
